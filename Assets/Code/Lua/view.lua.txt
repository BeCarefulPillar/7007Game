--[[local xluaUtil = require"xlua.util"
local function AddListener(t, event, inst, fn)
    local listeners = t[event]
    if not listeners then
        listeners = {}
        t[event] = listeners
    end
    
    local listener_fns = listeners[inst]
    if not listener_fns then
        listener_fns = {}
        listeners[inst] = listener_fns
    end
    
    --source.event_listeners[event][self][1]

    table.insert(listener_fns, fn)
end--]]

function VIEW(_ctor)
    local c = {}
    c.__index = c
    c._ctor = _ctor
    --[[c.ListenForEvent = function (self, event, fn, source )
        --print ("Listen for event", self, event, source)
        source = source or self
        if not source.event_listeners then
            source.event_listeners = {}
        end

        AddListener(source.event_listeners, event, self, fn)


        if not self.event_listening then
            self.event_listening = {}
        end

        AddListener(self.event_listening, event, source, fn)
    end

    c.SendEvent = function (self, event, data )
        if self.event_listeners then
            local listeners = self.event_listeners[event]
            if listeners then
                for entity, fns in pairs(listeners) do
                    for i,fn in ipairs(fns) do
                        fn(self, data)
                    end
                end
            end
        end
    end

    c.async_yield_return = function(self, to_yield, cb)
        self.view:YieldAndCallback(to_yield, cb)
    end

    c.Yield_Return = function(self, to_yield)
        return xluaUtil.async_to_sync(self.async_yield_return)(self, to_yield, nil)
    end

    c.StartCoroutine = function(self, func)
        return xluaUtil.coroutine_call(func)
    end

    c.DelayCall = function(self, func, delay)
        return function(...)
            local params = {...}
            table.insert(params, 1, delay)
            table.insert(params, 1, func)
            self.view:DelayCall(table.unpack(params))
        end
    end

    c.RepeatingCall = function(self, func, repeatRate, delay)
        if delay == nil then
            delay = 0
        end
        return function(...)
            local params = {...}
            table.insert(params, 1, delay)
            table.insert(params, 1, repeatRate)
            table.insert(params, 1, func)
            self.view:RepeatingCall(table.unpack(params))
        end
    end

    c.DelayFrame = function(self, func, frame)
        return function(...)
            local params = {...}
            table.insert(params, 1, frame)
            table.insert(params, 1, func)
            self.view:DelayFrame(table.unpack(params))
        end
    end--]]

    local mt = {}
    mt.__call = function(tbl, ...)
        local obj = {}
        setmetatable(obj, c)
        if c._ctor then
            local _view, _data = ...
            obj.view = _view
            obj.data = _data
            if _data then
                obj._onInit   = _data.onInit
                obj._onPostInit = _data.onPostInit
                obj._onPreDeinit = _data.onPreDeinit
                obj._onDeinit = _data.onDeinit
            end
            c._ctor(obj, ...)
        end
        return obj
    end
    setmetatable(c, mt)
    return c
end